# Developer Primer

## Как использовать Memory Bank

- Все ключевые решения фиксируйте в decisionLog.md с датой, автором и обоснованием.
- Для новых участников — начните с projectBrief.md и productContext.md.
- Используйте systemPatterns.md для описания повторяющихся архитектурных решений.
- В каждом режиме (Architect, Code, Ask, Debug) следуйте YAML-конфигу в custom_modes/.
- Для интеграции с AI-ассистентами используйте REST/MCP endpoint для автоматического логирования событий.
- Пример заполнения — см. knowledge_packages/*.md 

## Синхронизация с MCP/Task Tracker

> **Важно:** Memory Bank не предназначен для ручного ведения задач, багов или улучшений. Все подобные события фиксируются только в MCP/Task Tracker, а Memory Bank служит журналом и контекстным отражением для AI, автоматизации и команды.

### Рекомендации
- Создавайте и обновляйте задачи только через MCP (API, UI, CLI).
- Memory Bank автоматически отражает события, статусы и решения из MCP.
- ACT (AI Context Tracker) отслеживает действия в MCP и обновляет Memory Bank.
- Не добавляйте задачи напрямую в Memory Bank.

### Пример workflow
1. Задача создаётся в MCP.
2. MCP обновляет статус и отправляет событие в Memory Bank.
3. ACT логирует действия и обновляет контекст.
4. Баги/улучшения фиксируются только в MCP, а Memory Bank отражает эти события. 

### Чеклист: Проверка подключения к MCP/Task Tracker

- [ ] Выполнен healthcheck MCP API (`/health`)
- [ ] Получен валидный ответ и статус "OK"
- [ ] Тестовая задача из MCP появилась в Memory Bank
- [ ] Логи интеграции фиксируют успешную синхронизацию
- [ ] В интерфейсе Memory Bank отображается статус подключения

#### Инструкция
1. Проверьте, что MCP API доступен по адресу `/health` и возвращает статус `ok`.
2. Создайте тестовую задачу через MCP (UI/API).
3. Убедитесь, что задача автоматически отражается в Memory Bank (`decisionLog.md`, `activeContext.md`).
4. Проверьте логи интеграции (например, `integrationLog.md` или system log).
5. В UI/CLI Memory Bank должен отображаться статус подключения к MCP.

#### Пример Python-скрипта для healthcheck
```python
import requests

def check_mcp_connection(mcp_url, token):
    try:
        resp = requests.get(f'{mcp_url}/health', headers={'Authorization': f'Bearer {token}'})
        if resp.status_code == 200 and resp.json().get('status') == 'ok':
            print('MCP подключён')
            return True
        else:
            print('Ошибка подключения к MCP:', resp.text)
            return False
    except Exception as e:
        print('Ошибка:', e)
        return False
``` 

### Лог-файл интеграции
Ведите integrationLog.md для всех попыток синхронизации с MCP (см. шаблон).

### Автотесты интеграции
- Реализуйте регулярные тесты доступности MCP, корректности синхронизации и актуальности данных.
- Пример теста:
```python
# test_mcp_integration.py
assert check_mcp_connection(mcp_url, token)
```

### UI/CLI-индикатор статуса
- В интерфейсе Memory Bank отображайте статус подключения к MCP.
- CLI-команда: `memory-bank check-mcp-connection`

### Автоматические уведомления о сбоях
- Настройте оповещения (Slack, email, Sentry) при ошибках интеграции.
- Пример: при 3 неудачных попытках sync — уведомить DevOps.

### Документация по ошибкам и FAQ
- Разделите типовые ошибки (401, 500, timeout) и способы их устранения.

### Архивация, индексация, быстрый поиск
- При росте объёма knowledge packages и логов переносите устаревшие файлы в архив (memory-bank/archive/).
- Для поиска используйте индексацию по ключевым словам, датам, авто-генерацию оглавлений.

### План миграции структуры
- Перед изменениями делайте полный бэкап.
- Используйте миграционные скрипты для переноса данных.
- Все миграции фиксируйте в auditLog.md.

### DRP и восстановление
- При сбое используйте последний бэкап для восстановления.
- Храните резервные копии в облаке и локально.
- Проводите регулярные учения по восстановлению (DRP).

### Onboarding checklist
- [ ] Прочитать developer-primer.md и README.md
- [ ] Ознакомиться с core-файлами и knowledge packages
- [ ] Добавить тестовый knowledge package
- [ ] Ознакомиться с changelog и auditLog.md
- [ ] Настроить бэкапы и протестировать восстановление

### Git-история и changelog
- Все изменения фиксируются в git.
- При каждом pull request обновляйте CHANGELOG.md.
- Используйте шаблон changelog из корня проекта.

## Сценарии для AI-ассистента (AI Automation Scenarios)

- Для архивации knowledge packages вызывай:
  `mcp archive-knowledge-package <file>`
- Для миграции структуры:
  `mcp migrate-memory-bank --from <v1> --to <v2>`
- Для восстановления из бэкапа:
  `mcp restore-memory-bank <backup-file>`
- Для обновления changelog:
  `mcp update-changelog <message>`
- Для теста DRP:
  `mcp test-drp`
- Для поиска:
  `mcp search-knowledge <keyword>`

> **Важно:** Не редактируй архивные, changelog и audit файлы напрямую — только через команды MCP!

### Примеры промптов для AI
- "Архивируй knowledge package phase-dev.md"
- "Проведи тест DRP"
- "Восстанови Memory Bank из последнего бэкапа"
- "Обнови changelog после миграции"

## Автоматизация при завершении задачи

При завершении задачи MCP должен автоматически:
1. Архивировать связанный knowledge package:
   `mcp archive-knowledge-package <file>`
2. Обновить changelog:
   `mcp update-changelog "Задача <ID> завершена, knowledge package архивирован"`
3. Зафиксировать событие в auditLog.md:
   `[YYYY-MM-DD HH:MM] [mcp-server] [TASK_COMPLETE] Задача <ID> завершена, архивирован <file>`
4. Провести индексацию архивов:
   `mcp index-archive`

### Workflow завершения задачи
- Пользователь/AI завершает задачу в MCP
- MCP выполняет шаги 1-4 автоматически
- Все события логируются и доступны для поиска

### Пример промпта для AI
- "Заверши задачу #123 и заархивируй связанный knowledge package"

## Автоматизация при открытии задачи

При открытии новой задачи MCP должен автоматически:
1. Создать связанный knowledge package по шаблону:
   `mcp create-knowledge-package <file> --template <template>`
2. Зафиксировать событие в auditLog.md:
   `[YYYY-MM-DD HH:MM] [mcp-server] [TASK_OPEN] Открыта задача <ID>, создан <file>`
3. Обновить changelog:
   `mcp update-changelog "Открыта задача <ID>, создан knowledge package"`
4. Провести индексацию knowledge packages:
   `mcp index-knowledge`

### Workflow открытия задачи
- Пользователь/AI открывает новую задачу в MCP
- MCP выполняет шаги 1-4 автоматически
- Все события логируются и доступны для поиска

### Пример промпта для AI
- "Открой новую задачу и создай knowledge package по шаблону phase-init"

## Автоматизация для задач аудита и поиска багов

- Если задача содержит "аудит", "найти баги", "проверить авторизацию/регистрацию":
  1. Создай knowledge package по шаблону audit или feature-auth.
  2. Добавь чеклист аудита и секцию для найденных багов.
  3. Зафиксируй событие в auditLog.md и changelog.
  4. Индексируй knowledge packages.
  5. (Опционально) Создай подзадачи для каждого найденного бага.

### Workflow
- Пользователь/AI формулирует задачу: "Провести аудит авторизации и регистрации, найти баги."
- MCP/AI определяет тип задачи (audit), создаёт knowledge package, добавляет чеклист, логирует событие, индексирует, создаёт подзадачи для багов.

### Пример шаблона knowledge package для аудита
```markdown
# Knowledge Package: Аудит авторизации и регистрации

## Цели
- Проверить безопасность и корректность авторизации/регистрации
- Найти баги и уязвимости

## Чеклист аудита
- [ ] Проверка валидации входных данных
- [ ] Проверка обработки ошибок
- [ ] Тестирование на SQL-инъекции
- [ ] Проверка на brute-force
- [ ] Проверка логирования событий
- [ ] Проверка восстановления пароля

## Найденные баги
- [ ] (заполнить после аудита)
```

## Расширенный Epic Workflow: анализ, улучшения, бизнес-процесс

- При создании Epic AI/MCP должен:
  1. Проанализировать документацию, инфраструктуру и существующие knowledge packages для генерации полного пула подзадач.
  2. Оценить сроки реализации (таймлайн) для каждой подзадачи и всего Epic.
  3. Сформировать бизнес-процесс: какие этапы, что идёт следующим пулом, какие зависимости.
  4. Зафиксировать риски (особенно по безопасности) и потенциальные профиты (выгоды) для бизнеса.
  5. Определить необходимые инструменты и интеграции (например, лендинг, бот для контента, крон для рассылки, интеграция с соцсетями).
  6. Провести аудит используемых пакетов и сервисов.
  7. При появлении новых данных или улучшений — создать новый knowledge package для фиксации изменений, улучшений, новых рисков и профитов.

### Workflow
- Пользователь/AI формулирует Epic: "Epic: интеграция с соцсетями и автоматизация контента".
- MCP/AI анализирует документацию, инфраструктуру, существующие knowledge packages, формирует пул подзадач, оценивает сроки, риски, профиты, инструменты, интеграции, бизнес-процесс, проводит аудит пакетов, фиксирует всё в knowledge package Epic и, при необходимости, создаёт новые knowledge packages для изменений.

### Пример расширенного шаблона knowledge package для Epic
```markdown
# Knowledge Package: Epic — Интеграция с соцсетями и автоматизация контента

## Цели
- Автоматизировать генерацию и публикацию контента в соцсетях

## Анализ документации и инфраструктуры
- Документация: (ссылки, выводы)
- Инфраструктура: (описание, количество серверов, сервисы)
- Существующие knowledge packages: (перечень, анализ)

## Список подзадач
- [ ] Разработать лендинг
- [ ] Создать бота для генерации контента
- [ ] Настроить крон для рассылки
- [ ] Интегрировать с ВК, Facebook, Telegram
- [ ] Провести аудит безопасности интеграций
- [ ] Провести аудит используемых npm/pip пакетов

## Таймлайн
- Лендинг: 2 недели
- Бот: 1 неделя
- Крон: 2 дня
- Интеграции: 1 неделя
- Аудит: 3 дня

## Бизнес-процесс
- Генерация → Модерация → Публикация → Аналитика
- Следующий пул: автоматизация аналитики, интеграция с новыми платформами

## Риски
- Уязвимости в интеграциях
- Потеря доступа к соцсетям
- Нарушение SLA по рассылке

## Профиты
- Рост охвата аудитории
- Снижение ручного труда
- Повышение скорости публикаций

## Необходимые инструменты
- Node.js, Python, VK API, Facebook API, cron, CI/CD

## Аудит пакетов
- (результаты npm audit, pip check и т.д.)

## Новые knowledge packages
- (создавать при появлении новых данных, улучшений, рисков)
```

## Работа со снапшотами (Snapshots) и AI-ассистентом

### Что такое Snapshot
- Снапшот — это структурированный снимок состояния проекта, задач, правил, knowledge packages и истории на определённый момент времени.
- Используется для быстрого восстановления, клонирования, интеграции, отката и стандартизации новых задач.

### Как AI-ассистент может работать со снапшотами
- Инициировать создание снапшота через REST API MCP:
  - Промпт: "Сделай снапшот проекта перед миграцией"
  - Пример curl:
    ```sh
    curl -X POST "http://localhost:8001/projects/1/snapshot" -H "X-API-KEY: ..."
    ```
  - Пример Python:
    ```python
    import requests
    resp = requests.post('http://localhost:8001/projects/1/snapshot', headers={'X-API-KEY': '...'})
    print(resp.json())
    ```
- Использовать снапшот как шаблон для новых задач/проектов:
  - Промпт: "Создай новую задачу на основе снапшота X"
  - Импортировать снапшот как новый проект:
    ```sh
    curl -H "X-API-KEY: ..." -F "file=@snapshot.zip" http://localhost:8001/projects/import
    ```
  - Слить снапшот с текущим проектом:
    ```sh
    curl -H "X-API-KEY: ..." -F "file=@snapshot.zip" -F "dry_run=false" http://localhost:8001/projects/1/merge
    ```
- Откатить проект к состоянию снапшота:
  - Промпт: "Откатить проект к снапшоту X"
  - Пример curl:
    ```sh
    curl -X POST "http://localhost:8001/projects/1/rollback" -H "X-API-KEY: ..." -d '{"snapshot": "snapshot-1-2024-06-19T12-00-00"}'
    ```

### Best practices
- Используйте снапшоты как "живые" шаблоны для новых задач, интеграций и миграций.
- Перед крупными изменениями или миграциями всегда создавайте снапшот.
- Для новых проектов или фич анализируйте существующие снапшоты и выбирайте наиболее подходящий как основу.
- Все действия со снапшотами фиксируйте в changelog и auditLog.md.

### Примеры промптов для AI
- "Сделай снапшот проекта перед миграцией"
- "Создай новую интеграцию Stripe, используя структуру из снапшота X"
- "Откатить проект к состоянию снапшота X"

## Глубокая интеграция AI-ассистента

- AI-ассистент анализирует историю изменений, changelog, auditLog.md, knowledge packages.
- Сам предлагает или инициирует:
  - Создание снапшота при рисках, merge, release, завершении Epic
  - Откат к стабильному снапшоту при ошибках
  - Генерацию knowledge package при новых паттернах, багах, улучшениях
  - Сравнение версий, аудит изменений, внедрение best practices
- Все действия AI фиксируются в auditLog.md и changelog.

### Примеры промптов для AI
- "Рекомендую создать снапшот перед слиянием — создать сейчас?"
- "Обнаружен баг — создать knowledge package и зафиксировать?"
- "Сравнить текущую реализацию с успешным снапшотом?"
- "Внедрить best practices из knowledge package X?"

### Best practices для AI-инициированных действий
- Всегда логировать автоматические действия AI в auditLog.md и changelog
- Перед откатом или изменением — предлагать пользователю подтвердить действие
- При генерации knowledge package — использовать шаблоны и фиксировать источник (причину)
- Анализировать историю ошибок и успехов для проактивных советов

## Примеры автоматизации для AI-ассистента

### 1. Создание снапшота перед merge/release
**Промпт:**
«Рекомендую создать снапшот перед слиянием — создать сейчас?»
**Автоматизация:**
- AI вызывает MCP endpoint:
  ```python
  import requests
  resp = requests.post('http://localhost:8001/projects/1/snapshot', headers={'X-API-KEY': '...'})
  ```
- После подтверждения пользователя — логирует событие в auditLog.md и changelog.

### 2. Генерация knowledge package при баге/паттерне
**Промпт:**
«Обнаружен баг — создать knowledge package и зафиксировать?»
**Автоматизация:**
- AI создает файл в knowledge_packages/ с шаблоном для бага/паттерна.
- Добавляет запись в changelog и auditLog.md.

### 3. Откат к стабильному снапшоту
**Промпт:**
«В последних коммитах обнаружено много ошибок. Откатить проект к снапшоту snapshot-X?»
**Автоматизация:**
- После подтверждения пользователя — вызывает MCP endpoint для отката:
  ```python
  resp = requests.post('http://localhost:8001/projects/1/rollback', headers={'X-API-KEY': '...'}, json={'snapshot': 'snapshot-X'})
  ```
- Логирует событие.

### 4. Сравнение с успешным снапшотом
**Промпт:**
«Сравнить текущую реализацию с успешным снапшотом snapshot-Y?»
**Автоматизация:**
- AI извлекает файлы из снапшота, делает diff с текущей версией, показывает различия пользователю.
- Логирует результат сравнения.

### 5. Внедрение best practices из knowledge package
**Промпт:**
«Внедрить best practices из knowledge package X?»
**Автоматизация:**
- AI анализирует шаблон, предлагает изменения в коде/процессах, фиксирует внедрение в changelog и auditLog.md.

### 6. Автоматические действия по расписанию или событиям
- Раз в неделю AI предлагает сделать снапшот, провести аудит, обновить документацию.

### Best practices для автоматизации
- Всегда спрашивать подтверждение пользователя для критичных действий (откат, удаление, overwrite).
- Логировать все автоматические действия AI.
- Использовать шаблоны knowledge packages для новых багов, паттернов, улучшений.
- Анализировать историю ошибок и успехов для проактивных советов.

### CREATIVE MODE (Design)

CREATIVE MODE используется для генерации архитектурных и UI-решений, мозгового штурма, визуализации идей и фиксации креативных паттернов.

**Workflow:**
1. Активируйте CREATIVE MODE (см. custom_modes/creative_instructions.md).
2. Оформляйте идеи и решения в файлах creative-*.md (knowledge_packages/ или отдельная папка).
3. Визуализируйте архитектуру/процессы с помощью Mermaid.
4. После согласования — переносите финальное решение в decisionLog.md и systemPatterns.md.

**Best practices:**
- Фиксируйте альтернативные варианты и обсуждения.
- Используйте Mermaid для сложных схем.
- Все креативные решения должны быть доступны команде.
- После утверждения — логируйте итоговое решение.

**Пример:**
- Создайте файл knowledge_packages/creative-new-auth-flow.md с вариантами архитектуры и схемой в Mermaid.
- После выбора решения — добавьте запись в decisionLog.md и systemPatterns.md.

---

# Архитектура хранения и обмена знаниями (2024)

## 1. Структура хранения
- **archive/** (в корне): для каждого origin (project_id) отдельная подпапка (например, archive/mcp/), где хранятся knowledge packages, changelog, auditLog, projectBrief и др. Только для обмена и архивирования.
- **memory-bank/**: только шаблоны (template), core-файлы, инструкции, best practices. Не содержит рабочих или архивных данных.
- **projects/**: активные данные проектов (по необходимости).

## 2. Federation и обмен знаниями
- Все federation/import/export выполняются только через archive/<origin>/.
- memory-bank используется только как шаблон для новых проектов.
- Экспорт/импорт knowledge packages — только по origin, нельзя экспортировать/импортировать все данные сразу.
- Все операции логируются в changelog и auditLog соответствующего origin.

## 3. CLI/серверные команды (примеры)
```bash
mcp federation export --project mcp --out archive/mcp/export_2024-06-19.zip
mcp federation import --file archive/ai-assistant/export_2024-06-19.zip --project ai-assistant
mcp federation audit --project client-x
mcp federation log --project mcp
```

## 4. Best practices
- Перед импортом делайте бэкап локальных данных origin.
- Проверяйте метаданные (origin, версия, дата) перед слиянием.
- Не храните в archive активные или рабочие файлы.
- Все federation-операции требуют подтверждения.
- memory-bank — только шаблоны, не участвует в обмене рабочими данными.

## 5. Краткая инструкция для команды
1. Для обмена знаниями используйте только archive/<origin>/.
2. Для новых проектов — копируйте шаблоны из memory-bank/.
3. Для экспорта: используйте CLI-команду с указанием origin.
4. Для импорта: используйте CLI-команду, указывая архив и origin.
5. Все действия фиксируйте в changelog и auditLog.
6. При возникновении вопросов — обращайтесь к README.md в archive, memory-bank, federation.